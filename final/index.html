<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Senior Project</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				font-family: Monospace;
				background-color: #000;
				color: #fff;
				margin: 0px;
				overflow: hidden;
			}
			#info {
				color: #fff;
				position: absolute;
				top: 10px;
				width: 100%;
				text-align: center;
				z-index: 100;
				display:block;
			}
		</style>
	</head>

	<body>
		<!-- bar at top with model selection -->
		<div id="info">
		    <select id="model">
		      <option value="RandomFemale">RandomFemale</option>
		      <option value="RandomMale">RandomMale</option>
		    </select>
		    <input id="load" type="button" value="load"/>
		</div>
    
		<script src="js/three.min.js"></script>
		<script src="js/MTLLoader.js"></script>
		<script src="js/OBJMTLLoader.js"></script>
		<script src="js/Detector.js"></script>
		<script src="js/stats.min.js"></script>

		<script>
			var container, stats;

			var camera, scene, renderer;

			var mouseX = 0, mouseY = 0, scrollZ = 0;

			var windowHalfX = window.innerWidth / 2;
			var windowHalfY = window.innerHeight / 2;

			init();
			animate();

			// load a new model
			var loadButton = document.getElementById("load");
			loadButton.onclick = function save() {
				// get the div with the canvas element
				var c = document.getElementById('canvas');
				// remove the div with the canvas element
				var remElement = (c.parentNode).removeChild(c);
				// redraw
			  	init();
			}
      
			function init() {
				// create a new div container for the element
				container = document.createElement('div');
				// give the new div an id of "canvas"
				container.setAttribute("id", "canvas")
        
				document.body.appendChild(container);

        		// PerspectiveCamera(fov, aspect, near, far)
				camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 2500);
				// distance of camera from model
				camera.position.z = 500;

				/* scene */
				scene = new THREE.Scene();

				var ambient = new THREE.AmbientLight(0x101030);
				scene.add(ambient);

				var directionalLight = new THREE.DirectionalLight( 0xffeedd );
				directionalLight.position.set(0, 0, 1).normalize();
				scene.add(directionalLight);

				/* model */
				// get model name from html element
				var model = document.getElementById("model").value;
				var loader = new THREE.OBJMTLLoader();
				loader.addEventListener('load', function (event) {
					var object = event.content;
					object.position.y = 0;
					scene.add(object);
				});
				// use html element's value as the filename and location of the model's files
				loader.load(model + '/' + model + '.obj', model + '/' + model + '.mtl');

				renderer = new THREE.WebGLRenderer();
				renderer.setSize(window.innerWidth, window.innerHeight);
				container.appendChild(renderer.domElement);

				/* mouse event listeners */
				document.addEventListener('mousemove', onDocumentMouseMove, false);
				window.addEventListener('resize', onWindowResize, false);
				// IE9, Chrome, Safari, Opera
				container.addEventListener('mousewheel', MouseWheelHandler, false);
				// Firefox
				container.addEventListener('DOMMouseScroll', MouseWheelHandler, false);
			}
      
			function onDocumentMouseMove(event) {
				// controls sensitivity of mouse movements
				mouseX = (event.clientX - windowHalfX) * 2;
				mouseY = (event.clientY - windowHalfY) * 2;
			}		

			function onWindowResize() {
				windowHalfX = window.innerWidth / 2;
				windowHalfY = window.innerHeight / 2;

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize(window.innerWidth, window.innerHeight);
			}

			function MouseWheelHandler(event) {
				var event = window.event || event; // old IE support
				scrollZ = Math.max(-1, Math.min(1, (event.wheelDelta || -event.detail)));
				return false;
			}

			function animate() {
				requestAnimationFrame(animate);
				render();
			}

			function render() {
				camera.position.x += (mouseX - camera.position.x) * .05;
				camera.position.y += (-mouseY - camera.position.y) * .05;
				camera.position.z += -scrollZ * 20;
				// reset scrollZ to prevent continuous zooming
				scrollZ = 0;

				camera.lookAt(scene.position);

				renderer.render(scene, camera);
			}
		</script>
	</body>
</html>